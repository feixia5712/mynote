### 迭代器协议和生成器

##### 什么是迭代器协议

1.迭代器协议是指：对象必须提供一个next方法，执行该方法要么返回迭代中的下一项，要么就引起一个StopIteration异常，以终止迭代 （只能往后走不能往前退）

2.可迭代对象：实现了迭代器协议的对象（如何实现：对象内部定义一个__iter__()方法）

3.协议是一种约定，可迭代对象实现了迭代器协议，python的内部工具（如for循环，sum，min，max函数等)使用迭代器协议访问对象。

##### python中强大的for循环

for循环的本质：循环所有对象，全都是使用迭代器协议。

正本清源：

很多人会想，for循环的本质就是遵循迭代器协议去访问对象，那么for循环的对象肯定都是迭代器了啊，没错，那既然这样，for循环可以遍历（字符串，列表，元组，字典，集合，文件对象），那这些类型的数据肯定都是可迭代对象啊？但是，我他妈的为什么定义一个列表l=[1,2,3,4]没有l.next()方法，打脸么。

 

==(字符串，列表，元组，字典，集合，文件对象）这些都不是可迭代对象==，只不过在for循环式，调用了他们内部的__iter__方法，把他们变成了可迭代对象

然后for循环调用可迭代对象的__next__方法去取值，而且for循环会捕捉StopIteration异常，以终止迭代

```
l=['a','b','c']
#一:下标访问方式
print(l[0])
print(l[1])
print(l[2])
# print(l[3])#超出边界报错:IndexError

#二:遵循迭代器协议访问方式
diedai_l=l.__iter__()
print(diedai_l.__next__())
print(diedai_l.__next__())
print(diedai_l.__next__())
# print(diedai_l.__next__())#超出边界报错:StopIteration

#三:for循环访问方式
#for循环l本质就是遵循迭代器协议的访问方式,先调用diedai_l=l.__iter__()方法,或者直接diedai_l=iter(l),然后依次执行diedai_l.next(),直到for循环捕捉到StopIteration终止循环
　 #for循环所有对象的本质都是一样的原理

for i in l:#diedai_l=l.__iter__()
    print(i) #i=diedai_l.next()

#四:用while去模拟for循环做的事情
diedai_l=l.__iter__()
while True:
    try:
        print(diedai_l.__next__())
    except StopIteration:
        print('迭代完毕了,循环终止了')
        break
```
总结：for循环就是基于迭代器协议提供了一个统一的可以遍历所有对象的方法，即在遍历之前，先调用对象的__iter__方法将其转换成一个迭代器，然后使用迭代器协议去实现循环访问，这样所有的对象就都可以通过for循环来遍历了，

##### 生成器

什么是生成器？

可以理解为一种数据类型，这种数据类型自动实现了迭代器协议（其他的数据类型需要调用自己内置的__iter__方法），所以生成器就是可迭代对象

 

生成器分类及在python中的表现形式：（Python有两种不同的方式提供生成器）

1.生成器函数：常规函数定义，但是，使用yield语句而不是return语句返回结果。yield语句一次返回一个结果，在每个结果中间，挂起函数的状态，以便下次重它离开的地方继续执行

2.生成器表达式：类似于列表推导，但是，生成器返回按需产生结果的一个对象，而不是一次构建一个结果列表

 

为何使用生成器之生成器的优点

Python使用生成器对延迟操作提供了支持。所谓延迟操作，是指在需要的时候才产生结果，而不是立即产生结果。这也是生成器的主要好处。

 

生成器小结：

1.是可迭代对象

2.实现了延迟计算,省内存啊

3.生成器本质和其他的数据类型一样，都是实现了迭代器协议，只不过生成器附加了一个延迟计算省内存的好处，其余的可迭代对象可没有这点好处，记住喽！！！

总结：

1.把列表解析的[]换成()得到的就是生成器表达式

2.列表解析与生成器表达式都是一种便利的编程方式，只不过生成器表达式更节省内存

3.Python不但使用迭代器协议，让for循环变得更加通用。大部分内置函数，也是使用迭代器协议访问对象的。例如，

sum函数是Python的内置函数，该函数使用迭代器协议访问对象，而生成器实现了迭代器协议，所以，我们可以直接这样计算一系列值的和：

```
sum(x ** 2 for x in xrange(4))
```

===分析区别==

语法上和函数类似：生成器函数和常规函数几乎是一样的。它们都是使用def语句进行定义，差别在于，生成器使用yield语句返回一个值，而常规函数使用return语句返回一个值

自动实现迭代器协议：对于生成器，Python会自动实现迭代器协议，以便应用到迭代背景中（如for循环，sum函数）。由于生成器自动实现了迭代器协议，所以，我们可以调用它的next方法，并且，在没有值可以返回的时候，生成器自动产生StopIteration异常

状态挂起：生成器使用yield语句返回一个值。yield语句挂起该生成器函数的状态，保留足够的信息，以便之后从它离开的地方继续执行

理解yield

```
1.txt

{'name':'北京','population':10}
{'name':'南京','population':100000}
{'name':'山东','population':10000}
{'name':'山西','population':19999}

---------------------------------------------

def get_provice_population(filename):
    with open(filename) as f:
        for line in f:
            p=eval(line)
            yield p['population']
gen=get_provice_population('1.txt')

print (gen)

all_population=sum(gen)#sum函数会遍历生成器

print (all_population)

print('----------------')
for p in gen:
    print(p/all_population)  #不会输出
```
执行上面这段代码，将不会有任何输出，这是因为，生成器只能遍历一次。在我们执行sum语句的时候，就遍历了我们的生成器，当我们再次遍历我们的生成器的时候，将不会有任何记录。所以，上面的代码不会有任何输出。

因此，生成器的唯一注意事项就是：生成器只能遍历一次。

yield总结

```
对yield的总结
　　（1）通常的for..in...循环中，in后面是一个数组，这个数组就是一个可迭代对象，类似的还有链表，字符串，文件。他可以是a = [1,2,3]，也可以是a = [x*x for x in range(3)]。

它的缺点也很明显，就是所有数据都在内存里面，如果有海量的数据，将会非常耗内存。

　　（2）生成器是可以迭代的，但是只可以读取它一次。因为用的时候才生成，比如a = (x*x for x in range(3))。!!!!注意这里是小括号而不是方括号。

　　（3）生成器（generator）能够迭代的关键是他有next()方法，工作原理就是通过重复调用next()方法，直到捕获一个异常。

　　（4）带有yield的函数不再是一个普通的函数，而是一个生成器generator，可用于迭代

　　（5）yield是一个类似return 的关键字，迭代一次遇到yield的时候就返回yield后面或者右面的值。而且下一次迭代的时候，从上一次迭代遇到的yield后面的代码开始执行

　　（6）yield就是return返回的一个值，并且记住这个返回的位置。下一次迭代就从这个位置开始。

　　（7）带有yield的函数不仅仅是只用于for循环，而且可用于某个函数的参数，只要这个函数的参数也允许迭代参数。

　　（8）send()和next()的区别就在于send可传递参数给yield表达式，这时候传递的参数就会作为yield表达式的值，而yield的参数是返回给调用者的值，也就是说send可以强行修改上一个yield表达式值。

　　（9）send()和next()都有返回值，他们的返回值是当前迭代遇到的yield的时候，yield后面表达式的值，其实就是当前迭代yield后面的参数。

　　（10）第一次调用时候必须先next（）或send（）,否则会报错，send后之所以为None是因为这时候没有上一个yield，所以也可以认为next（）等同于send(None)
```

